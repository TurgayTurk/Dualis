using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;

namespace SourceGen;

/// <summary>
/// Roslyn incremental generator that emits the <c>AddDualis</c> extension method.
/// The generated method registers discovered CQRS handlers and pipeline behaviors
/// and wires up notification infrastructure based on <c>DualizorOptions</c>.
/// </summary>
[Generator]
public sealed class ServiceCollectionExtensionGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Configures the generator pipeline and registers the source output callback.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<(bool exists, bool isTrue)> prop = context.AnalyzerConfigOptionsProvider
            .Select(static (opts, _) =>
            {
                if (opts.GlobalOptions.TryGetValue("build_property.DualisEnableGenerator", out string? v))
                {
                    return (true, string.Equals(v, "true", System.StringComparison.OrdinalIgnoreCase));
                }
                return (false, false);
            });

        IncrementalValueProvider<bool> enabledByAttr = context.CompilationProvider
            .Select(static (comp, _) => HasEnableAttribute(comp));

        IncrementalValueProvider<bool> enabled = prop.Combine(enabledByAttr)
            .Select(static (pair, _) =>
            {
                (bool exists, bool isTrue) = pair.Left;
                bool byAttr = pair.Right;
                bool byProp = exists && isTrue; // enable only when property explicitly true
                return byProp || byAttr;
            });

        IncrementalValueProvider<(Compilation Compilation, ImmutableArray<ISymbol> QueryHandlers, ImmutableArray<ISymbol> CommandHandlers, ImmutableArray<ISymbol> RequestHandlers, ImmutableArray<ISymbol> NotificationHandlers, ImmutableArray<ISymbol> RequestBehaviors, ImmutableArray<ISymbol> VoidBehaviors, ImmutableArray<ISymbol> NotificationBehaviors)> items = SharedHandlerDiscovery.DiscoverHandlers(context);

        context.RegisterSourceOutput(items.Combine(enabled), static (spc, tuple) =>
        {
            ((Compilation Compilation,
              ImmutableArray<ISymbol> QueryHandlers,
              ImmutableArray<ISymbol> CommandHandlers,
              ImmutableArray<ISymbol> RequestHandlers,
              ImmutableArray<ISymbol> NotificationHandlers,
              ImmutableArray<ISymbol> RequestBehaviors,
              ImmutableArray<ISymbol> VoidBehaviors,
              ImmutableArray<ISymbol> NotificationBehaviors) source, bool isEnabled) = tuple;
            if (!isEnabled)
            {
                return; // generator disabled in this project
            }

            ImmutableArray<ISymbol> queryHandlers = source.QueryHandlers;
            ImmutableArray<ISymbol> commandHandlers = source.CommandHandlers;
            ImmutableArray<ISymbol> requestHandlers = source.RequestHandlers;
            ImmutableArray<ISymbol> notificationHandlers = source.NotificationHandlers;
            ImmutableArray<ISymbol> requestBehaviors = source.RequestBehaviors;
            ImmutableArray<ISymbol> voidBehaviors = source.VoidBehaviors;

            StringBuilder sb = new();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS1591, CA1812, CA1822, IDE0051, IDE0060");
            sb.AppendLine("using System;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            sb.AppendLine("using Microsoft.Extensions.Options;");
            sb.AppendLine("using Dualis;");
            sb.AppendLine("using Dualis.CQRS;");
            sb.AppendLine("using Dualis.Pipeline;");
            sb.AppendLine("using Dualis.Notifications;");
            sb.AppendLine();
            sb.AppendLine("namespace Dualis;");
            sb.AppendLine();
            sb.AppendLine("public static class ServiceCollectionExtensions");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Registers Dualis core services, discovered handlers and pipeline behaviors.");
            sb.AppendLine("    /// Honors flags configured through <c>DualizorOptions</c>.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"services\">The DI container.</param>");
            sb.AppendLine("    /// <param name=\"configure\">Optional configuration callback for <c>DualizorOptions</c>.</param>");
            sb.AppendLine("    /// <returns>The same <see cref=\"IServiceCollection\"/> for chaining.</returns>");
            sb.AppendLine("    public static IServiceCollection AddDualis(this IServiceCollection services, System.Action<DualizorOptions>? configure = null)");
            sb.AppendLine("    {");
            sb.AppendLine("        // Options");
            sb.AppendLine("        services.AddOptions<DualizorOptions>();");
            sb.AppendLine("        if (configure is not null) services.Configure(configure);");
            sb.AppendLine();
            sb.AppendLine("        // Eagerly apply manual registries while ServiceCollection is mutable and compute auto-registration flags");
            sb.AppendLine("        bool autoRegisterBehaviors = true;");
            sb.AppendLine("        bool autoRegisterCqrsHandlers = true;");
            sb.AppendLine("        bool autoRegisterNotificationHandlers = true;");
            sb.AppendLine("        if (configure is not null)");
            sb.AppendLine("        {");
            sb.AppendLine("            DualizorOptions tmp = new DualizorOptions();");
            sb.AppendLine("            configure(tmp);");
            sb.AppendLine("            tmp.Pipelines.Apply(services);");
            sb.AppendLine("            tmp.CQRS.Apply(services);");
            sb.AppendLine("            tmp.Notifications.Apply(services);");
            sb.AppendLine("            autoRegisterBehaviors = tmp.RegisterDiscoveredBehaviors && tmp.Pipelines.AutoRegisterEnabled;");
            sb.AppendLine("            autoRegisterCqrsHandlers = tmp.RegisterDiscoveredCqrsHandlers;");
            sb.AppendLine("            autoRegisterNotificationHandlers = tmp.RegisterDiscoveredNotificationHandlers;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Auto-register discovered pipeline behaviors if enabled");
            sb.AppendLine("        if (autoRegisterBehaviors)");
            sb.AppendLine("        {");
            sb.AppendLine("            // Request/Response behaviors");
            AppendRequestBehaviorRegistrations(sb, requestBehaviors);
            sb.AppendLine("            // Void request behaviors");
            AppendVoidBehaviorRegistrations(sb, voidBehaviors);
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Generated mediator (single instance per scope) - if available");
            sb.AppendLine("        Type? dualizorType = Type.GetType(\"Dualis.Dualizor\");");
            sb.AppendLine("        if (dualizorType is not null)");
            sb.AppendLine("        {");
            sb.AppendLine("            services.TryAdd(new ServiceDescriptor(dualizorType, dualizorType, ServiceLifetime.Scoped));");
            sb.AppendLine("            services.TryAdd(ServiceDescriptor.Scoped(typeof(IDualizor), sp => (IDualizor)sp.GetRequiredService(dualizorType))); ");
            sb.AppendLine("            services.TryAdd(ServiceDescriptor.Scoped(typeof(ISender), sp => (ISender)sp.GetRequiredService(dualizorType))); ");
            sb.AppendLine("            services.TryAdd(ServiceDescriptor.Scoped(typeof(IPublisher), sp => (IPublisher)sp.GetRequiredService(dualizorType))); ");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Auto-register discovered handlers based on flags");
            sb.AppendLine("        if (autoRegisterCqrsHandlers)");
            sb.AppendLine("        {");
            AppendCommandRegistrations(sb, commandHandlers);
            sb.AppendLine();
            AppendQueryRegistrations(sb, queryHandlers);
            sb.AppendLine();
            AppendUnifiedRequestRegistrations(sb, requestHandlers);
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (autoRegisterNotificationHandlers)");
            sb.AppendLine("        {");
            AppendNotificationRegistrations(sb, notificationHandlers);
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Infra (publisher + context)");
            sb.AppendLine("        services.AddScoped<INotificationPublisher>(sp =>");
            sb.AppendLine("        {");
            sb.AppendLine("            DualizorOptions options = sp.GetRequiredService<IOptions<DualizorOptions>>().Value;");
            sb.AppendLine("            return options.NotificationPublisherFactory(sp);");
            sb.AppendLine("        });");
            sb.AppendLine("        services.AddScoped(sp =>");
            sb.AppendLine("        {");
            sb.AppendLine("            DualizorOptions options = sp.GetRequiredService<IOptions<DualizorOptions>>().Value;");
            sb.AppendLine("            return new NotificationPublishContext(options.NotificationFailureBehavior, options.MaxPublishDegreeOfParallelism);");
            sb.AppendLine("        });");
            sb.AppendLine("        services.AddScoped<SequentialNotificationPublisher>();");
            sb.AppendLine("        services.AddScoped<ParallelWhenAllNotificationPublisher>();");
            sb.AppendLine();
            sb.AppendLine("        return services;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine("#pragma warning restore CS1591, CA1812, CA1822, IDE0051, IDE0060");

            spc.AddSource("ServiceCollectionExtensions.g.cs", sb.ToString());
        });
    }

    private static bool HasEnableAttribute(Compilation comp) => comp.Assembly.GetAttributes()
        .Select(a => a.AttributeClass)
        .Any(cls =>
        {
            if (cls is null)
            {
                return false;
            }
            string name = cls.Name;
            string ns = cls.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return (name == "EnableDualisGenerationAttribute" || name == "EnableDualisGeneration") && ns == "global::Dualis";
        });

    /// <summary>
    /// Determines whether a generic interface contains any open generic type parameters.
    /// </summary>
    /// <param name="iface">The interface symbol to inspect.</param>
    /// <returns><see langword="true"/> if any type arguments are open generic parameters; otherwise <see langword="false"/>.</returns>
    private static bool HasTypeParameters(INamedTypeSymbol iface)
        => iface.TypeArguments.Any(static t => t is ITypeParameterSymbol);

    private static int GetPipelineOrder(INamedTypeSymbol behavior)
    {
        int? min = null;
        foreach (AttributeData attr in behavior.GetAttributes())
        {
            string ns = attr.AttributeClass?.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? string.Empty;
            string name = attr.AttributeClass?.Name ?? string.Empty;
            if (name == "PipelineOrderAttribute" && ns == "global::Dualis.Pipeline" && attr.ConstructorArguments.Length == 1)
            {
                TypedConstant value = attr.ConstructorArguments[0];
                if (value.Value is int i)
                {
                    min = min is null ? i : Math.Min(min.Value, i);
                }
            }
        }
        return min ?? 0;
    }

    /// <summary>
    /// Emits DI registrations for request/response pipeline behaviors.
    /// Generates open or closed mappings depending on the implementation shape.
    /// Supports both IPipelineBehavior and IPipelineBehaviour.
    /// </summary>
    private static void AppendRequestBehaviorRegistrations(StringBuilder sb, ImmutableArray<ISymbol> behaviorSymbols)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol behavior in behaviorSymbols.OfType<INamedTypeSymbol>()
                     .OrderBy(s => GetPipelineOrder(s))
                     .ThenBy(s => s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            IEnumerable<INamedTypeSymbol> ifaceMatches = behavior.AllInterfaces
                .Where(i => (i.Name == "IPipelineBehavior" || i.Name == "IPipelineBehaviour")
                            && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.Pipeline"
                            && i.TypeArguments.Length == 2);

            foreach (INamedTypeSymbol iface in ifaceMatches)
            {
                string service;
                string impl;

                if (HasTypeParameters(iface))
                {
                    if (!behavior.IsUnboundGenericType && !behavior.IsGenericType)
                    {
                        // Cannot bind open service to non-generic implementation
                        continue;
                    }

                    string openService = iface.ConstructUnboundGenericType().ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string openImpl = (behavior.IsUnboundGenericType ? behavior : behavior.ConstructUnboundGenericType()).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({openService})";
                    impl = $"typeof({openImpl})";
                }
                else
                {
                    string closedService = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string implType = behavior.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({closedService})";
                    impl = $"typeof({implType})";
                }

                string key = $"{service}|{impl}";
                if (emitted.Add(key))
                {
                    sb.AppendLine($"            services.TryAddEnumerable(ServiceDescriptor.Scoped({service}, {impl}));");
                }
            }
        }
    }

    /// <summary>
    /// Emits DI registrations for void request pipeline behaviors.
    /// Generates open or closed mappings depending on the implementation shape.
    /// </summary>
    private static void AppendVoidBehaviorRegistrations(StringBuilder sb, ImmutableArray<ISymbol> behaviorSymbols)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol behavior in behaviorSymbols.OfType<INamedTypeSymbol>()
                     .OrderBy(s => GetPipelineOrder(s))
                     .ThenBy(s => s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            IEnumerable<INamedTypeSymbol> ifaceMatches = behavior.AllInterfaces
                .Where(i => i.Name == "IPipelineBehavior"
                            && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.Pipeline"
                            && i.TypeArguments.Length == 1);

            foreach (INamedTypeSymbol iface in ifaceMatches)
            {
                string service;
                string impl;

                if (HasTypeParameters(iface))
                {
                    if (!behavior.IsUnboundGenericType && !behavior.IsGenericType)
                    {
                        continue;
                    }

                    string openService = iface.ConstructUnboundGenericType().ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string openImpl = (behavior.IsUnboundGenericType ? behavior : behavior.ConstructUnboundGenericType()).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({openService})";
                    impl = $"typeof({openImpl})";
                }
                else
                {
                    string closedService = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string implType = behavior.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({closedService})";
                    impl = $"typeof({implType})";
                }

                string key = $"{service}|{impl}";
                if (emitted.Add(key))
                {
                    sb.AppendLine($"            services.TryAddEnumerable(ServiceDescriptor.Scoped({service}, {impl}));");
                }
            }
        }
    }

    /// <summary>
    /// Appends DI registrations for all discovered command handlers.
    /// </summary>
    /// <param name="sb">The target <see cref="StringBuilder"/> for generated code.</param>
    /// <param name="commandHandlers">The set of symbols that implement <c>ICommandHandler</c>.</param>
    private static void AppendCommandRegistrations(StringBuilder sb, ImmutableArray<ISymbol> commandHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in commandHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<(INamedTypeSymbol Iface, ImmutableArray<ITypeSymbol> TypeArgs)> matches = handlerSymbol.AllInterfaces
                .Where(i => i.Name == "ICommandHandler" && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.CQRS" && (i.TypeArguments.Length == 1 || i.TypeArguments.Length == 2) && !HasTypeParameters(i))
                .Select(i => (i, i.TypeArguments));

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach ((INamedTypeSymbol Iface, ImmutableArray<ITypeSymbol> TypeArgs) in matches)
            {
                string ifaceNs = Iface.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string ifaceFull = ifaceNs + ".ICommandHandler";

                if (TypeArgs.Length == 2)
                {
                    string commandType = TypeArgs[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string responseType = TypeArgs[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"C2|{ifaceFull}|{commandType}|{responseType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<{ifaceFull}<{commandType}, {responseType}>, {handlerName}>();");
                    }
                }
                else
                {
                    string commandType = TypeArgs[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"C1|{ifaceFull}|{commandType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<{ifaceFull}<{commandType}>, {handlerName}>();");
                    }
                }
            }
        }
    }      

    /// <summary>
    /// Appends DI registrations for all discovered query handlers.
    /// </summary>
    /// <param name="sb">The target <see cref="StringBuilder"/> for generated code.</param>
    /// <param name="queryHandlers">The set of symbols that implement <c>IQueryHandler</c>.</param>
    private static void AppendQueryRegistrations(StringBuilder sb, ImmutableArray<ISymbol> queryHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in queryHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<(INamedTypeSymbol Iface, ImmutableArray<ITypeSymbol> TypeArgs)> matches = handlerSymbol.AllInterfaces
                .Where(i => i.Name == "IQueryHandler" && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.CQRS" && (i.TypeArguments.Length == 1 || i.TypeArguments.Length == 2) && !HasTypeParameters(i))
                .Select(i => (i, i.TypeArguments));

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach ((INamedTypeSymbol Iface, ImmutableArray<ITypeSymbol> TypeArgs) in matches)
            {
                string ifaceNs = Iface.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string ifaceFull = ifaceNs + ".IQueryHandler";

                if (TypeArgs.Length == 2)
                {
                    string queryType = TypeArgs[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string responseType = TypeArgs[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"Q2|{ifaceFull}|{queryType}|{responseType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<{ifaceFull}<{queryType}, {responseType}>, {handlerName}>();");
                    }
                }
                else
                {
                    string queryType = TypeArgs[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"Q1|{ifaceFull}|{queryType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<{ifaceFull}<{queryType}>, {handlerName}>();");
                    }
                }
            }
        }
    }

    /// <summary>
    /// Appends DI registrations for all discovered unified request handlers (IRequestHandler).
    /// </summary>
    private static void AppendUnifiedRequestRegistrations(StringBuilder sb, ImmutableArray<ISymbol> requestHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in requestHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<(INamedTypeSymbol Iface, ImmutableArray<ITypeSymbol> TypeArgs)> matches = handlerSymbol.AllInterfaces
                .Where(i => i.Name == "IRequestHandler" && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.CQRS" && (i.TypeArguments.Length == 1 || i.TypeArguments.Length == 2) && !HasTypeParameters(i))
                .Select(i => (i, i.TypeArguments));

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach ((INamedTypeSymbol Iface, ImmutableArray<ITypeSymbol> TypeArgs) in matches)
            {
                string ifaceNs = Iface.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string ifaceFull = ifaceNs + ".IRequestHandler";

                if (TypeArgs.Length == 2)
                {
                    string requestType = TypeArgs[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string responseType = TypeArgs[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"R2|{ifaceFull}|{requestType}|{responseType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<{ifaceFull}<{requestType}, {responseType}>, {handlerName}>();");
                    }
                }
                else
                {
                    string requestType = TypeArgs[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"R1|{ifaceFull}|{requestType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<{ifaceFull}<{requestType}>, {handlerName}>();");
                    }
                }
            }
        }
    }

    /// <summary>
    /// Appends DI registrations for all discovered notification handlers.
    /// </summary>
    private static void AppendNotificationRegistrations(StringBuilder sb, ImmutableArray<ISymbol> notificationHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in notificationHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<ImmutableArray<ITypeSymbol>> interfaceTypeArguments = handlerSymbol.AllInterfaces
                .Where(i =>
                    i.Name == "INotificationHandler" &&
                    i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.Notifications" &&
                    i.TypeArguments.Length == 1 &&
                    !HasTypeParameters(i))
                .Select(i => i.TypeArguments);

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach (ImmutableArray<ITypeSymbol> typeArguments in interfaceTypeArguments)
            {
                string notificationType = typeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string key = $"N1|{notificationType}|{handlerName}";
                if (emitted.Add(key))
                {
                    sb.AppendLine($"        services.TryAddScoped<INotificationHandler<{notificationType}>, {handlerName}>();");
                }
            }
        }
    }
}
