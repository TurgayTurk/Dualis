using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;

namespace SourceGen;

/// <summary>
/// Roslyn incremental generator that emits the <c>AddDualis</c> extension method.
/// The generated method registers discovered CQRS handlers and pipeline behaviors
/// and wires up notification infrastructure based on <c>DualizorOptions</c>.
/// </summary>
[Generator]
public sealed class ServiceCollectionExtensionGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Configures the generator pipeline and registers the source output callback.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<(
            Compilation Compilation,
            ImmutableArray<ISymbol> QueryHandlers,
            ImmutableArray<ISymbol> CommandHandlers,
            ImmutableArray<ISymbol> NotificationHandlers,
            ImmutableArray<ISymbol> RequestBehaviors,
            ImmutableArray<ISymbol> VoidBehaviors,
            ImmutableArray<ISymbol> NotificationBehaviors)> items =
            SharedHandlerDiscovery.DiscoverHandlers(context);

        context.RegisterSourceOutput(items, static (spc, source) =>
        {
            ImmutableArray<ISymbol> queryHandlers = source.QueryHandlers;
            ImmutableArray<ISymbol> commandHandlers = source.CommandHandlers;
            ImmutableArray<ISymbol> notificationHandlers = source.NotificationHandlers;
            ImmutableArray<ISymbol> requestBehaviors = source.RequestBehaviors;
            ImmutableArray<ISymbol> voidBehaviors = source.VoidBehaviors;
            // ImmutableArray<ISymbol> notificationBehaviors = source.NotificationBehaviors; // deprecated

            StringBuilder sb = new();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS1591, CA1812, CA1822, IDE0051, IDE0060");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            sb.AppendLine("using Microsoft.Extensions.Options;");
            sb.AppendLine("using Dualis;");
            sb.AppendLine("using Dualis.CQRS.Commands;");
            sb.AppendLine("using Dualis.CQRS.Queries;");
            sb.AppendLine("using Dualis.Pipeline;");
            sb.AppendLine("using Dualis.Notifications;");
            sb.AppendLine();
            sb.AppendLine("namespace Dualis;");
            sb.AppendLine();
            sb.AppendLine("public static class ServiceCollectionExtensions");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Registers Dualis core services, discovered handlers and pipeline behaviors.");
            sb.AppendLine("    /// Honors flags configured through <c>DualizorOptions</c>.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"services\">The DI container.</param>");
            sb.AppendLine("    /// <param name=\"configure\">Optional configuration callback for <c>DualizorOptions</c>.</param>");
            sb.AppendLine("    /// <returns>The same <see cref=\"IServiceCollection\"/> for chaining.</returns>");
            sb.AppendLine("    public static IServiceCollection AddDualis(this IServiceCollection services, System.Action<DualizorOptions>? configure = null)");
            sb.AppendLine("    {");
            sb.AppendLine("        // Options");
            sb.AppendLine("        services.AddOptions<DualizorOptions>();");
            sb.AppendLine("        if (configure is not null) services.Configure(configure);");
            sb.AppendLine();
            sb.AppendLine("        // Eagerly apply manual registries while ServiceCollection is mutable and compute auto-registration flags");
            sb.AppendLine("        bool autoRegisterBehaviors = true;");
            sb.AppendLine("        bool autoRegisterCqrsHandlers = true;");
            sb.AppendLine("        bool autoRegisterNotificationHandlers = true;");
            sb.AppendLine("        if (configure is not null)");
            sb.AppendLine("        {");
            sb.AppendLine("            DualizorOptions tmp = new DualizorOptions();");
            sb.AppendLine("            configure(tmp);");
            sb.AppendLine("            tmp.Pipelines.Apply(services);");
            sb.AppendLine("            tmp.CQRS.Apply(services);");
            sb.AppendLine("            tmp.Notifications.Apply(services);");
            sb.AppendLine("            autoRegisterBehaviors = tmp.RegisterDiscoveredBehaviors && tmp.Pipelines.AutoRegisterEnabled;");
            sb.AppendLine("            autoRegisterCqrsHandlers = tmp.RegisterDiscoveredCqrsHandlers;");
            sb.AppendLine("            autoRegisterNotificationHandlers = tmp.RegisterDiscoveredNotificationHandlers;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Auto-register discovered pipeline behaviors if enabled");
            sb.AppendLine("        if (autoRegisterBehaviors)");
            sb.AppendLine("        {");
            sb.AppendLine("            // Request/Response behaviors");
            AppendRequestBehaviorRegistrations(sb, requestBehaviors);
            sb.AppendLine("            // Void request behaviors");
            AppendVoidBehaviorRegistrations(sb, voidBehaviors);
            sb.AppendLine("            // Notification behaviors: deprecated INotificationBehavior is not registered anymore. Use unified IPipelineBehaviour<T, Unit>.");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Generated mediator (single instance per scope)");
            sb.AppendLine("        services.AddScoped<Dualizor>();");
            sb.AppendLine("        services.TryAdd(ServiceDescriptor.Scoped(typeof(IDualizor), sp => (IDualizor)sp.GetRequiredService<Dualizor>()));");
            sb.AppendLine("        services.TryAdd(ServiceDescriptor.Scoped(typeof(ISender), sp => (ISender)sp.GetRequiredService<Dualizor>()));");
            sb.AppendLine("        services.TryAdd(ServiceDescriptor.Scoped(typeof(IPublisher), sp => (IPublisher)sp.GetRequiredService<Dualizor>()));");
            sb.AppendLine();
            sb.AppendLine("        // Auto-register discovered handlers based on flags");
            sb.AppendLine("        if (autoRegisterCqrsHandlers)");
            sb.AppendLine("        {");
            AppendCommandRegistrations(sb, commandHandlers);
            sb.AppendLine();
            AppendQueryRegistrations(sb, queryHandlers);
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (autoRegisterNotificationHandlers)");
            sb.AppendLine("        {");
            AppendNotificationRegistrations(sb, notificationHandlers);
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        // Infra (publisher + context)");
            sb.AppendLine("        services.AddScoped<INotificationPublisher>(sp =>");
            sb.AppendLine("        {");
            sb.AppendLine("            DualizorOptions options = sp.GetRequiredService<IOptions<DualizorOptions>>().Value;");
            sb.AppendLine("            return options.NotificationPublisherFactory(sp);");
            sb.AppendLine("        });");
            sb.AppendLine("        services.AddScoped(sp =>");
            sb.AppendLine("        {");
            sb.AppendLine("            DualizorOptions options = sp.GetRequiredService<IOptions<DualizorOptions>>().Value;");
            sb.AppendLine("            return new NotificationPublishContext(options.NotificationFailureBehavior, options.MaxPublishDegreeOfParallelism);");
            sb.AppendLine("        });");
            sb.AppendLine("        services.AddScoped<SequentialNotificationPublisher>();");
            sb.AppendLine("        services.AddScoped<ParallelWhenAllNotificationPublisher>();");
            sb.AppendLine();
            sb.AppendLine("        return services;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine("#pragma warning restore CS1591, CA1812, CA1822, IDE0051, IDE0060");

            spc.AddSource("ServiceCollectionExtensions.g.cs", sb.ToString());
        });
    }

    /// <summary>
    /// Determines whether a generic interface contains any open generic type parameters.
    /// </summary>
    /// <param name="iface">The interface symbol to inspect.</param>
    /// <returns><see langword="true"/> if any type arguments are open generic parameters; otherwise <see langword="false"/>.</returns>
    private static bool HasTypeParameters(INamedTypeSymbol iface)
        => iface.TypeArguments.Any(static t => t is ITypeParameterSymbol);

    private static int GetPipelineOrder(INamedTypeSymbol behavior)
    {
        int? min = null;
        foreach (AttributeData attr in behavior.GetAttributes())
        {
            string ns = attr.AttributeClass?.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? string.Empty;
            string name = attr.AttributeClass?.Name ?? string.Empty;
            if (name == "PipelineOrderAttribute" && ns == "global::Dualis.Pipeline" && attr.ConstructorArguments.Length == 1)
            {
                TypedConstant value = attr.ConstructorArguments[0];
                if (value.Value is int i)
                {
                    min = min is null ? i : Math.Min(min.Value, i);
                }
            }
        }
        return min ?? 0;
    }

    /// <summary>
    /// Emits DI registrations for request/response pipeline behaviors.
    /// Generates open or closed mappings depending on the implementation shape.
    /// Supports both IPipelineBehavior and IPipelineBehaviour.
    /// </summary>
    private static void AppendRequestBehaviorRegistrations(StringBuilder sb, ImmutableArray<ISymbol> behaviorSymbols)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol behavior in behaviorSymbols.OfType<INamedTypeSymbol>()
                     .OrderBy(s => GetPipelineOrder(s))
                     .ThenBy(s => s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            IEnumerable<INamedTypeSymbol> ifaceMatches = behavior.AllInterfaces
                .Where(i => (i.Name == "IPipelineBehavior" || i.Name == "IPipelineBehaviour")
                            && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.Pipeline"
                            && i.TypeArguments.Length == 2);

            foreach (INamedTypeSymbol iface in ifaceMatches)
            {
                string service;
                string impl;

                if (HasTypeParameters(iface))
                {
                    if (!behavior.IsUnboundGenericType && !behavior.IsGenericType)
                    {
                        // Cannot bind open service to non-generic implementation
                        continue;
                    }

                    string openService = iface.ConstructUnboundGenericType().ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string openImpl = (behavior.IsUnboundGenericType ? behavior : behavior.ConstructUnboundGenericType()).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({openService})";
                    impl = $"typeof({openImpl})";
                }
                else
                {
                    string closedService = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string implType = behavior.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({closedService})";
                    impl = $"typeof({implType})";
                }

                string key = $"{service}|{impl}";
                if (emitted.Add(key))
                {
                    sb.AppendLine($"            services.TryAddEnumerable(ServiceDescriptor.Scoped({service}, {impl}));");
                }
            }
        }
    }

    /// <summary>
    /// Emits DI registrations for void request pipeline behaviors.
    /// Generates open or closed mappings depending on the implementation shape.
    /// </summary>
    private static void AppendVoidBehaviorRegistrations(StringBuilder sb, ImmutableArray<ISymbol> behaviorSymbols)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol behavior in behaviorSymbols.OfType<INamedTypeSymbol>()
                     .OrderBy(s => GetPipelineOrder(s))
                     .ThenBy(s => s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            IEnumerable<INamedTypeSymbol> ifaceMatches = behavior.AllInterfaces
                .Where(i => i.Name == "IPipelineBehavior"
                            && i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.Pipeline"
                            && i.TypeArguments.Length == 1);

            foreach (INamedTypeSymbol iface in ifaceMatches)
            {
                string service;
                string impl;

                if (HasTypeParameters(iface))
                {
                    if (!behavior.IsUnboundGenericType && !behavior.IsGenericType)
                    {
                        continue;
                    }

                    string openService = iface.ConstructUnboundGenericType().ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string openImpl = (behavior.IsUnboundGenericType ? behavior : behavior.ConstructUnboundGenericType()).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({openService})";
                    impl = $"typeof({openImpl})";
                }
                else
                {
                    string closedService = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string implType = behavior.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    service = $"typeof({closedService})";
                    impl = $"typeof({implType})";
                }

                string key = $"{service}|{impl}";
                if (emitted.Add(key))
                {
                    sb.AppendLine($"            services.TryAddEnumerable(ServiceDescriptor.Scoped({service}, {impl}));");
                }
            }
        }
    }

    // AppendNotificationBehaviorRegistrations removed from call-site (deprecated path)

    /// <summary>
    /// Appends DI registrations for all discovered command handlers.
    /// </summary>
    /// <param name="sb">The target <see cref="StringBuilder"/> for generated code.</param>
    /// <param name="commandHandlers">The set of symbols that implement <c>ICommandHandler</c>.</param>
    private static void AppendCommandRegistrations(StringBuilder sb, ImmutableArray<ISymbol> commandHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in commandHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<ImmutableArray<ITypeSymbol>> interfaceTypeArguments = handlerSymbol.AllInterfaces
                .Where(i =>
                    i.Name == "ICommandHandler" &&
                    i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.CQRS.Commands" &&
                    (i.TypeArguments.Length == 1 || i.TypeArguments.Length == 2) &&
                    !HasTypeParameters(i))
                .Select(i => i.TypeArguments);

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach (ImmutableArray<ITypeSymbol> typeArguments in interfaceTypeArguments)
            {
                if (typeArguments.Length == 2)
                {
                    string commandType = typeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string responseType = typeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"C2|{commandType}|{responseType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<ICommandHandler<{commandType}, {responseType}>, {handlerName}>();");
                    }
                }
                else
                {
                    string commandType = typeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"C1|{commandType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<ICommandHandler<{commandType}>, {handlerName}>();");
                    }
                }
            }
        }
    }      

    /// <summary>
    /// Appends DI registrations for all discovered query handlers.
    /// </summary>
    /// <param name="sb">The target <see cref="StringBuilder"/> for generated code.</param>
    /// <param name="queryHandlers">The set of symbols that implement <c>IQueryHandler</c>.</param>
    private static void AppendQueryRegistrations(StringBuilder sb, ImmutableArray<ISymbol> queryHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in queryHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<ImmutableArray<ITypeSymbol>> interfaceTypeArguments = handlerSymbol.AllInterfaces
                .Where(i =>
                    i.Name == "IQueryHandler" &&
                    i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.CQRS.Queries" &&
                    (i.TypeArguments.Length == 1 || i.TypeArguments.Length == 2) &&
                    !HasTypeParameters(i))
                .Select(i => i.TypeArguments);

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach (ImmutableArray<ITypeSymbol> typeArguments in interfaceTypeArguments)
            {
                if (typeArguments.Length == 2)
                {
                    string queryType = typeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string responseType = typeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"Q2|{queryType}|{responseType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<IQueryHandler<{queryType}, {responseType}>, {handlerName}>();");
                    }
                }
                else
                {
                    string queryType = typeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    string key = $"Q1|{queryType}|{handlerName}";
                    if (emitted.Add(key))
                    {
                        sb.AppendLine($"        services.TryAddScoped<IQueryHandler<{queryType}>, {handlerName}>();");
                    }
                }
            }
        }
    }

    /// <summary>
    /// Appends DI registrations for all discovered notification handlers.
    /// </summary>
    private static void AppendNotificationRegistrations(StringBuilder sb, ImmutableArray<ISymbol> notificationHandlers)
    {
        HashSet<string> emitted = [];
        foreach (INamedTypeSymbol handlerSymbol in notificationHandlers.OfType<INamedTypeSymbol>())
        {
            if (handlerSymbol.TypeKind != TypeKind.Class || handlerSymbol.IsAbstract)
            {
                continue;
            }

            IEnumerable<ImmutableArray<ITypeSymbol>> interfaceTypeArguments = handlerSymbol.AllInterfaces
                .Where(i =>
                    i.Name == "INotificationHandler" &&
                    i.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Dualis.Notifications" &&
                    i.TypeArguments.Length == 1 &&
                    !HasTypeParameters(i))
                .Select(i => i.TypeArguments);

            string handlerName = handlerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            foreach (ImmutableArray<ITypeSymbol> typeArguments in interfaceTypeArguments)
            {
                string notificationType = typeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string key = $"N1|{notificationType}|{handlerName}";
                if (emitted.Add(key))
                {
                    sb.AppendLine($"        services.TryAddScoped<INotificationHandler<{notificationType}>, {handlerName}>();");
                }
            }
        }
    }
}
